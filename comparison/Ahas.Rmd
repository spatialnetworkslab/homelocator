---
title: "Ahas Method"
author: "Chen Qinqqing"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  html_document:
    toc: true 
    toc_depth: 4  
    number_sections: true  
    theme: united  
    highlight: tango  
    toc_float: true   
    code_folding: hide
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r load_library}
library(tidyverse)
library(magrittr)
library(sf)
library(lubridate)
library(furrr)
library(gridExtra)
library(tidycensus)
```


```{r load_data}
df <- read_csv("/Users/qingqing/Dropbox/SUTD/Ate/homelocator/data/lexington-with-GEOID-2012-2017.csv") 
df_sub <- df %>% 
  select(id, u_id, created_at, GEOID, text, screen_name) %>% 
  mutate(year = year(created_at), 
         month = month(created_at),
         day = day(created_at), 
         GEOID = as.character(GEOID)) 
head(df_sub)
#initialy, there are 95285 users 
```

```{r step1, message=FALSE, warning=FALSE}
# determing points of regular cells and separating them from random cells
## Regular cells-network cells: regularly visited by one person and from which the person has made calls on at least two different days a month, in our case, the cell treat as GEOID/location, the user should has sent tweets on the location at least two differnt days a month
## Random cells- a netwok cell: from which the one respondent has made calls on only one day a month
df_step1 <- df_sub %>% 
  group_by(u_id, GEOID, year, month, day) %>% 
  mutate(day_counts = n()) %>% 
  group_by(u_id, GEOID, year, month) %>% 
  mutate(n_day = n_distinct(day)) %>% 
  ungroup() 

regular_cells <- df_step1 %>% filter(n_day >= 2) # the number of users decreases from 95285 to 33399  (3904743tweets)
random_cells <- df_step1 %>% filter(n_day < 2)
```


```{r step2_toolow, message=FALSE, warning=FALSE}
#Regular cells are sorted by the number of days with calls, and if days overlap, by the number of calls. Here we sorted by the number of days with tweets, and if days overlap, by the number of tweets. 
options(future.globals.maxSize= 1073741824)
df_step2 <- regular_cells %>% 
  group_by(u_id, GEOID, year, month) %>% 
  mutate(month_counts = n()) %>% 
  ungroup() %>% 
  group_by(u_id) %>% 
  nest()

remove_lowUsers <- function(data){
  df <- data %>% 
    arrange(., desc(n_day), desc(month_counts)) %>% 
    select(GEOID, n_day, month_counts) %>% 
    unique() %>% 
    top_n(n=1) %>% 
    slice(1)
  if (df$n_day < 7){
    tibble::tibble(
      id = NA,
      created_at = NA,
      GEOID = NA, 
      text = NA, 
      screen_name = NA,
      year = NA, 
      month = NA, 
      day = NA, 
      day_counts = NA, 
      n_day = NA, 
      month_counts = NA)
  } else{
    data
  }
}

regular_cells <- df_step2 %>% 
  mutate(detect = future_map(data, remove_lowUsers)) %>% 
  select(-data) %>% 
  ungroup() %>% 
  unnest() %>% 
  na.omit()  #the number of users decreases from 33399 to 10401 (3547401)
```

```{r step2_toohigh, message=FALSE, warning=FALSE}
# remove top 1% users 
regular_cells <- regular_cells %>% 
  group_by(u_id) %>% 
  summarise(total_counts = n()) %>% 
  ungroup() %>% 
  arrange(., desc(total_counts)) %>% 
  slice(round(n_distinct(.$u_id)*0.01):n()) %>% 
  left_join(., regular_cells)     # the number of users decreases from 10401 to 10298 (2911498)
```

```{r step3}
#Determing home and work-time Anchor Points: the two regular locations that had the highest number of days with tweets are selected for the calculation of home and work-time anchor points, and the rest are moved directly to the last stages of the model, where they are called seconday anchor points.
df_step3 <- regular_cells %>% 
  select(c(u_id, GEOID, created_at, year, month, day, day_counts, month_counts, total_counts,n_day)) %>% 
  unite(date, year, month, day, sep = "-") %>% 
  mutate(date = as.Date(date)) %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, get_top2GEOID)) %>% 
  select(-data) %>% 
  unnest() %>% 
  ungroup() %>% 
  left_join(., regular_cells) 


get_top2GEOID <- function(data){
  data %>% 
    top_n(n=2, wt = n_tweets) %>% 
    head(., n=2)
}

to.times <- function(x) chron::times(paste0(x, ":00"))
determine_anchor_type <- function(data){
  avg_start_time <- data %>% 
    mutate(times = chron::times(strftime(created_at,"%H:%M:%S"))) %>% 
    unite(date, year, month, day, sep = "-") %>% 
    mutate(date = as.Date(date)) %>% 
    group_by(date) %>% 
    summarise(average_time = mean(times)) %>% 
    ungroup() %>% 
    summarise(avg = mean(average_time)) %>% 
    pull(., avg)
  sd_time <- data %>% 
    mutate(times = chron::times(strftime(created_at,"%H:%M:%S"))) %>% 
    unite(date, year, month, day, sep = "-") %>% 
    mutate(date = as.Date(date)) %>% 
    group_by(date) %>% 
    arrange(., times) %>% 
    top_n(n=1) %>% 
    slice(1) %>% 
    ungroup() %>% 
    summarise(sd_time = sd(times)) %>% 
    pull(., sd_time)
  if (avg_start_time > to.times("17:00") | (avg_start_time < to.times("17:00") & sd_time > 0.175)){
    tibble::tibble(anchor_type = "home")
    } else{
      tibble::tibble(anchor_type = "work place")
      }
}

if(file.exists("anchor_results.csv")){
  anchor_results <- read_csv("anchor_results.csv") %>% 
    mutate(GEOID = as.character(GEOID))
} else{
  anchor_results <- df_step3 %>% 
    group_by(u_id, GEOID) %>% 
    nest() %>% 
    mutate(detect=future_map(data, determine_anchor_type)) %>% 
    select(-data) %>% 
    unnest() %>% 
    group_by(u_id) %>% 
    mutate(anchor_type_n = n_distinct(anchor_type)) %>% 
    ungroup()
  write_csv(anchor_results, path = "anchor_results.csv")
}

anchor_results <- anchor_results %>% 
  group_by(u_id) %>% 
  mutate(n_geoid = n_distinct(GEOID)) %>% 
  ungroup()


oneHome <- anchor_results %>% 
  filter(n_geoid == 1) %>% 
  filter(anchor_type == "home")
oneWork <- anchor_results %>% 
  filter(n_geoid == 1) %>% 
  filter(anchor_type == "work place")
oneHome_oneWork <- anchor_results %>% 
  filter(n_geoid == 2) %>% 
  filter(anchor_type_n == 2)
twoHome <- anchor_results %>% 
  filter(n_geoid == 2) %>% 
  filter(anchor_type_n == 1) %>% 
  filter(anchor_type == "home")
twoWork <- anchor_results %>% 
  filter(n_geoid == 2) %>% 
  filter(anchor_type_n == 1) %>% 
  filter(anchor_type == "work place")

secondary_anchor_points <- anti_join(regular_cells, df_step3 %>% select(-n_date))
```

```{r step4, message=FALSE, warning=FALSE}
#Consideration of neighboring relationships in the case of two home or two work-time anchor points 
options(tigris_use_cache = TRUE, tigris_class="sf")
census_api_key("2fcf1623c436882ad5e62a47280ab732d815e363")
acs_ky <- tidycensus::get_acs(state = "KY", geography = "tract",
                  variables = c(medincome = "B19013_001"),
                  geometry = T, output = "wide", year = 2016)  %>%
                  st_transform(., "+init=epsg:4326") %>% 
  select(GEOID) %>% 
  mutate(id = 1:nrow(.))

st_queen <- function(a, b = a) st_relate(a, b, pattern = "F***T****")
neighbors <- st_queen(acs_ky)

detect_neighbor <- function(data){
  IDs <- data$id
  id_1 <- IDs[1]
  id_1_neighbors <- neighbors[[id_1]]
  id_2 <- IDs[2]
  if(id_2 %in% id_1_neighbors){
    return("neighboring cell")
  } else{
    return("non-neighboring cell")
  }
}

twoHome <- twoHome %>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id) 
twoHome_neighbor_detect <- twoHome %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) 
twoHome <- twoHome %>% 
  left_join(., twoHome_neighbor_detect, by = c("u_id"))


twoWork <- twoWork %>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id) 
twoWork_neighbor_detect <- twoWork %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) 
twoWork <- twoWork %>% 
  left_join(., twoWork_neighbor_detect, by = c("u_id"))

## neighboring cells dataset
twoHome_neighbous <- twoHome %>% 
  filter(neighboring == "neighboring cell") %>% 
  select(-id, -neighboring) %>% 
  left_join(., regular_cells)
twoWork_neighous <- twoWork %>% 
  filter(neighboring == "non-neighboring cell") %>% 
  select(-id, -neighboring)

## in case the anchor points were located in neighboring cells, keep the most visited anchor point.
mostVisit_anchor_detect <- function(data){
  if(n_distinct(data$n_date) == 2){
   data %>% 
    top_n(n=1, wt=n_date) %>% 
    slice(., 1) %>%
    pull(., GEOID)
} else{
  data %>% 
    top_n(n=1, wt = n_tweets) %>% 
    slice(., 1) %>% 
    pull(., GEOID)
  }
}
twoHome_neighbous_mostVisit <- twoHome_neighbous %>% 
  unite(date, year, month, day, sep = "-") %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, mostVisit_anchor_detect) %>% unlist()) %>% 
  select(-data) %>% 
  mutate(anchor_type = "home")

## after that, use the earlier list of regular cells of the same respondent again, and the third regular cell will be employed.
top3_regularCells <- regular_cells %>% 
  filter(u_id %in% twoHome_neighbous$u_id) %>% 
  select(c(u_id, GEOID, created_at, year, month, day, day_counts, month_counts, total_counts,n_day)) %>% 
  unite(date, year, month, day, sep = "-") %>% 
  mutate(date = as.Date(date)) %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, get_top3GEOID)) %>% 
  select(-data) %>% 
  unnest() %>% 
  ungroup() %>% 
  left_join(., regular_cells) 

get_top3GEOID <- function(data){
  data %>% 
    top_n(n=3, wt = n_tweets) %>% 
    head(., n=3)
}

## re-analyze the dataset in stage 3 and try to determine the missing home or work-time anchor point
anchor_results_reAnalyzed <- top3_regularCells %>% 
    group_by(u_id, GEOID) %>% 
    nest() %>% 
    mutate(detect=future_map(data, determine_anchor_type)) %>% 
    select(-data) %>% 
    unnest() %>% 
    group_by(u_id) %>% 
    mutate(anchor_type_n = n_distinct(anchor_type)) %>% 
    ungroup()

added_workplace <- anchor_results_reAnalyzed %>% 
  filter(anchor_type_n == 2 & anchor_type == "work place") 
added_oneHome_oneWork<- twoHome_neighbous_mostVisit %>% 
  filter(u_id %in% added_workplace$u_id) %>% 
  bind_rows(., d %>% select(-anchor_type_n)) %>% 
  mutate(anchor_type_n = 2) %>% 
  group_by(u_id) %>% 
  mutate(n_geoid = n_distinct(GEOID)) %>% 
  ungroup()


##the anchor points are not situated in neighboring cells, the two home or two work-time anchor points move on to the next stage (stage 5)
twoHome_not_neighbous <- twoHome %>% 
  filter(neighboring == "non-neighboring cell") %>% 
  select(-id, -neighboring)
twoWork_not_neighbous <- twoWork %>% 
  filter(neighboring == "non-neighboring cell") %>% 
  select(-id, -neighboring)
```









