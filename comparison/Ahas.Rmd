---
title: "Ahas Method"
author: "Chen Qinqqing"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  html_document:
    toc: true 
    toc_depth: 4  
    number_sections: true  
    theme: united  
    highlight: tango  
    toc_float: true   
    code_folding: hide
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r load_library}
library(tidyverse)
library(magrittr)
library(sf)
library(lubridate)
library(furrr)
library(gridExtra)
library(tidycensus)
```


```{r load_data}
df <- read_csv("/Users/qingqing/Dropbox/SUTD/Ate/homelocator/data/lexington-with-GEOID-2012-2017.csv") 
df <- df %>% 
  select(id, u_id, created_at, GEOID, text, screen_name) %>% 
  mutate(year = year(created_at), 
         month = month(created_at),
         day = day(created_at), 
         GEOID = as.character(GEOID)) 
head(df)
#initialy, there are 95285 users 
```

```{r step1, message=FALSE, warning=FALSE}
# determing points of regular cells and separating them from random cells
## Regular cells-network cells: regularly visited by one person and from which the person has made calls on at least two different days a month, in our case, the cell treat as GEOID/location, the user should has sent tweets on the location at least two differnt days a month
## Random cells- a netwok cell: from which the one respondent has made calls on only one day a month
df_step1 <- df %>% 
  group_by(u_id, GEOID, year, month, day) %>% 
  mutate(day_counts = n()) %>% 
  group_by(u_id, GEOID, year, month) %>% 
  mutate(n_day = n_distinct(day)) %>% 
  ungroup() 

regular_cells <- df_step1 %>% filter(n_day >= 2) # the number of users decreases from 95285 to 33399  (3904743tweets)
random_cells <- df_step1 %>% filter(n_day < 2)
```


```{r step2_toolow, message=FALSE, warning=FALSE}
#Regular cells are sorted by the number of days with calls, and if days overlap, by the number of calls. Here we sorted by the number of days with tweets, and if days overlap, by the number of tweets. 
options(future.globals.maxSize= 1073741824)
remove_lowUsers <- function(data){
  df <- data %>% 
    arrange(., desc(n_day), desc(month_counts)) %>% 
    select(GEOID, n_day, month_counts) %>% 
    unique() %>% 
    top_n(n=1) %>% 
    slice(1)
  if (df$n_day < 7){
    tibble::tibble(
      id = NA,
      created_at = NA,
      GEOID = NA, 
      text = NA, 
      screen_name = NA,
      year = NA, 
      month = NA, 
      day = NA, 
      day_counts = NA, 
      n_day = NA, 
      month_counts = NA)
  } else{
    data
  }
}

df_step2 <- regular_cells %>% 
  group_by(u_id, GEOID, year, month) %>% 
  mutate(month_counts = n()) %>% 
  ungroup() %>% 
  group_by(u_id) %>% 
  nest()
regular_cells <- df_step2 %>% 
  mutate(detect = future_map(data, remove_lowUsers)) %>% 
  select(-data) %>% 
  ungroup() %>% 
  unnest() %>% 
  na.omit()  #the number of users decreases from 33399 to 10401 (3547401)
```

```{r step2_toohigh, message=FALSE, warning=FALSE}
# remove top 1% users 
regular_cells <- regular_cells %>% 
  group_by(u_id) %>% 
  summarise(total_counts = n()) %>% 
  ungroup() %>% 
  arrange(., desc(total_counts)) %>% 
  slice(round(n_distinct(.$u_id)*0.01):n()) %>% 
  left_join(., regular_cells)     # the number of users decreases from 10401 to 10298 (2911498)
```

```{r step3, message=FALSE, warning=FALSE}
#Determing home and work-time Anchor Points: the two regular locations that had the highest number of days with tweets are selected for the calculation of home and work-time anchor points, and the rest are moved directly to the last stages of the model, where they are called seconday anchor points.
get_topN_GEOID <- function(data, topN){
  data %>% 
    top_n(n=topN, wt = n_tweets) %>% 
    head(., n = topN)
}
to.times <- function(x) chron::times(paste0(x, ":00"))
determine_anchor_type <- function(data){
  avg_start_time <- data %>% 
    mutate(times = chron::times(strftime(created_at,"%H:%M:%S"))) %>% 
    unite(date, year, month, day, sep = "-") %>% 
    mutate(date = as.Date(date)) %>% 
    group_by(date) %>% 
    summarise(average_time = mean(times)) %>% 
    ungroup() %>% 
    summarise(avg = mean(average_time)) %>% 
    pull(., avg)
  sd_time <- data %>% 
    mutate(times = chron::times(strftime(created_at,"%H:%M:%S"))) %>% 
    unite(date, year, month, day, sep = "-") %>% 
    mutate(date = as.Date(date)) %>% 
    group_by(date) %>% 
    arrange(., times) %>% 
    top_n(n=1) %>% 
    slice(1) %>% 
    ungroup() %>% 
    summarise(sd_time = sd(times)) %>% 
    pull(., sd_time)
  if (avg_start_time > to.times("17:00") | (avg_start_time < to.times("17:00") & sd_time > 0.175)){
    tibble::tibble(anchor_type = "home")
    } else{
      tibble::tibble(anchor_type = "work place")
      }
}

df_step3 <- regular_cells %>% 
  select(c(u_id, GEOID, created_at, year, month, day, day_counts, month_counts, total_counts,n_day)) %>% 
  unite(date, year, month, day, sep = "-") %>% 
  mutate(date = as.Date(date)) %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, function(x) get_topN_GEOID(x, 2))) %>% 
  select(-data) %>% 
  unnest() %>% 
  ungroup() %>% 
  left_join(., regular_cells) 

if(file.exists("anchor_results.csv")){
  anchor_results <- read_csv("anchor_results.csv") %>% 
    mutate(GEOID = as.character(GEOID)) 
} else{
  anchor_results <- df_step3 %>% 
    group_by(u_id, GEOID) %>% 
    nest() %>% 
    mutate(detect=future_map(data, determine_anchor_type)) %>% 
    select(-data) %>% 
    unnest() %>% 
    group_by(u_id) %>% 
    mutate(anchor_type_n = n_distinct(anchor_type),
           n_geoid = n_distinct(GEOID)) %>% 
    ungroup()
  write_csv(anchor_results, path = "anchor_results.csv")
}


#first iterated result 
oneHome <- anchor_results %>% filter(n_geoid == 1 & anchor_type == "home") 
oneWork <- anchor_results %>% filter(n_geoid == 1 & anchor_type == "work place") 
oneHome_oneWork <- anchor_results %>% filter(n_geoid == 2 & anchor_type_n == 2) 

twoHome <- anchor_results %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 1) %>% filter(anchor_type == "home")
twoWork <- anchor_results %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 1) %>% filter(anchor_type == "work place")
secondary_anchor_points <- anti_join(regular_cells, df_step3 %>% select(-n_date))

```

```{r step4_iterate_2, message=FALSE, warning=FALSE}
# Furthur look into twoHome 
#Consideration of neighboring relationships in the case of two home or two work-time anchor points 
options(tigris_use_cache = TRUE, tigris_class="sf")
census_api_key("2fcf1623c436882ad5e62a47280ab732d815e363")
acs_ky <- tidycensus::get_acs(state = "KY", geography = "tract",
                  variables = c(medincome = "B19013_001"),
                  geometry = T, output = "wide", year = 2016)  %>%
                  st_transform(., "+init=epsg:4326") %>% 
  select(GEOID) %>% 
  mutate(id = 1:nrow(.))

st_queen <- function(a, b = a) st_relate(a, b, pattern = "F***T****")
neighbors <- st_queen(acs_ky)
detect_neighbor <- function(data){
  IDs <- data$id
  id_1 <- IDs[1]
  id_1_neighbors <- neighbors[[id_1]]
  id_2 <- IDs[2]
  if(id_2 %in% id_1_neighbors){
    return("neighboring cell")
  } else{
    return("non-neighboring cell")
  }
}

twoHome <- twoHome %>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id) %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) %>% 
  left_join(twoHome, ., by = c("u_id"))


##the anchor points are not situated in neighboring cells, the two home or two work-time anchor points move on to the next stage (stage 5)
twoHome_not_neighbous <- twoHome %>% filter(neighboring == "non-neighboring cell") %>% select(-neighboring)
## neighboring cells dataset
twoHome_neighbous <- twoHome %>% filter(neighboring == "neighboring cell") %>% select(-neighboring) %>% left_join(., regular_cells)

## in case the anchor points were located in neighboring cells, keep the most visited anchor point.
mostVisit_anchor_detect <- function(data){
  if(n_distinct(data$n_date) == 2){
   data %>% 
    top_n(n=1, wt=n_date) %>% 
    slice(., 1) %>%
    pull(., GEOID)
} else{
  data %>% 
    top_n(n=1, wt = n_tweets) %>% 
    slice(., 1) %>% 
    pull(., GEOID)
  }
}

twoHome_Neigh_mostVisit <- twoHome_neighbous %>% 
  unite(date, year, month, day, sep = "-") %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, mostVisit_anchor_detect) %>% unlist()) %>% 
  select(-data) %>% 
  mutate(anchor_type = "home")

remove_second_GEOID <- function(neighbous, mostVisit){
  neighbous %>% 
    select(c(u_id, GEOID, anchor_type)) %>% 
    unique() %>% 
    anti_join(., mostVisit, by = c("u_id", "GEOID"))
}
removed_GEOIDs <- remove_second_GEOID(twoHome_neighbous, twoHome_Neigh_mostVisit)

## remove secondary GEOID dataset and get new regular cell, repeat stage 3 procesure 
regular_cells_2 <- anti_join(regular_cells, left_join(removed_GEOIDs, regular_cells, by = c("u_id", "GEOID")))
### second iterate 
df_step3_2 <- regular_cells_2 %>% 
  filter(u_id %in% twoHome_neighbous$u_id) %>% 
  select(c(u_id, GEOID, created_at, year, month, day, day_counts, month_counts, total_counts,n_day)) %>% 
  unite(date, year, month, day, sep = "-") %>% 
  mutate(date = as.Date(date)) %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, function(x) get_topN_GEOID(x, 2))) %>% 
  select(-data) %>% 
  unnest() %>% 
  ungroup() %>% 
  left_join(., regular_cells) 

if(file.exists("anchor_results_2.csv")){
  anchor_results_2 <- read_csv("anchor_results_2.csv") %>% 
    mutate(GEOID = as.character(GEOID)) 
} else{
  anchor_results_2 <- df_step3_2 %>% 
    group_by(u_id, GEOID) %>% 
    nest() %>% 
    mutate(detect=future_map(data, determine_anchor_type)) %>% 
    select(-data) %>% 
    unnest() %>% 
    group_by(u_id) %>% 
    mutate(anchor_type_n = n_distinct(anchor_type),
           n_geoid = n_distinct(GEOID)) %>% 
    ungroup()
  write_csv(anchor_results_2, path = "anchor_results_2.csv")
}

## add to dataset for each type
oneHome <- bind_rows(oneHome, (anchor_results_2 %>% filter(n_geoid == 1) %>% filter(anchor_type == "home")))
oneWork <- bind_rows(oneWork, (anchor_results_2 %>% filter(n_geoid == 1) %>% filter(anchor_type == "work place")))
oneHome_oneWork <- append(oneHome_oneWork, (anchor_results_2 %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 2)))

twoHome_2 <- anchor_results_2 %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 1) %>% filter(anchor_type == "home")
twoHome_2 <- twoHome_2 %>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id) %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) %>% 
  left_join(twoHome_2, ., by = c("u_id"))

## add to dataset 
twoHome_not_neighbous <- bind_rows(twoHome_not_neighbous, twoHome_2 %>% filter(neighboring == "non-neighboring cell") %>% select(-neighboring))
twoHome_neighbous <- twoHome_2 %>% filter(neighboring == "neighboring cell") %>% select(-neighboring) %>% left_join(., regular_cells)

# third iterate 
## in case the anchor points were located in neighboring cells, keep the most visited anchor point.
twoHome_Neigh_mostVisit <- twoHome_neighbous %>% 
  unite(date, year, month, day, sep = "-") %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, mostVisit_anchor_detect) %>% unlist()) %>% 
  select(-data) %>% 
  mutate(anchor_type = "home")

removed_GEOIDs <- remove_second_GEOID(twoHome_neighbous, twoHome_Neigh_mostVisit)

## remove secondary GEOID dataset and get new regular cell, repeat stage 3 procesure 
regular_cells_3 <- anti_join(regular_cells, left_join(removed_GEOIDs, regular_cells, by = c("u_id", "GEOID")))
### second iterate 
df_step3_3 <- regular_cells_3 %>% 
  filter(u_id %in% twoHome_neighbous$u_id) %>% 
  select(c(u_id, GEOID, created_at, year, month, day, day_counts, month_counts, total_counts,n_day)) %>% 
  unite(date, year, month, day, sep = "-") %>% 
  mutate(date = as.Date(date)) %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, function(x) get_topN_GEOID(x, 2))) %>% 
  select(-data) %>% 
  unnest() %>% 
  ungroup() %>% 
  left_join(., regular_cells) 

if(file.exists("anchor_results_3.csv")){
  anchor_results_3 <- read_csv("anchor_results_3.csv") %>% 
    mutate(GEOID = as.character(GEOID)) 
} else{
  anchor_results_3 <- df_step3_3 %>% 
    group_by(u_id, GEOID) %>% 
    nest() %>% 
    mutate(detect=future_map(data, determine_anchor_type)) %>% 
    select(-data) %>% 
    unnest() %>% 
    group_by(u_id) %>% 
    mutate(anchor_type_n = n_distinct(anchor_type),
           n_geoid = n_distinct(GEOID)) %>% 
    ungroup()
  write_csv(anchor_results_3, path = "anchor_results_3.csv")
}

## add to dataset for each type
oneHome <- bind_rows(oneHome, (anchor_results_3 %>% filter(n_geoid == 1) %>% filter(anchor_type == "home")))
oneWork <- bind_rows(oneWork, (anchor_results_3 %>% filter(n_geoid == 1) %>% filter(anchor_type == "work place")))
oneHome_oneWork <- append(oneHome_oneWork, (anchor_results_3 %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 2)))


twoHome_3 <- anchor_results_3 %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 1) %>% filter(anchor_type == "home") 
twoHome_3 <- twoHome_3%>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id) %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) %>% 
  left_join(twoHome_3, ., by = c("u_id"))

## add to dataset 
twoHome_not_neighbous <- bind_rows(twoHome_not_neighbous, twoHome_3 %>% filter(neighboring == "non-neighboring cell") %>% select(-neighboring))
twoHome_neighbous <- twoHome_3 %>% filter(neighboring == "neighboring cell") %>% select(-neighboring) %>% left_join(., regular_cells)
```

```{r step4, message=FALSE, warning=FALSE}
# Furthur look into twoWork 
twoWork <- twoWork %>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id)  %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) %>% 
  left_join(twoWork, ., by = c("u_id"))

##the anchor points are not situated in neighboring cells, the two home or two work-time anchor points move on to the next stage (stage 5)
twoWork_not_neighbous <- twoWork %>% filter(neighboring == "non-neighboring cell") %>% select(-neighboring)
## neighboring cells dataset
twoWork_neighbous <- twoWork %>% filter(neighboring == "neighboring cell") %>% select(-neighboring) %>% left_join(., regular_cells)

twoWork_Neigh_mostVisit <- twoWork_neighbous %>% 
  unite(date, year, month, day, sep = "-") %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, mostVisit_anchor_detect) %>% unlist()) %>% 
  select(-data) %>% 
  mutate(anchor_type = "work place")

removed_GEOIDs_work <- remove_second_GEOID(twoWork_neighbous, twoWork_Neigh_mostVisit)

## remove secondary GEOID dataset and get new regular cell, repeat stage 3 procesure 
regular_cells_2_work <- anti_join(regular_cells, left_join(removed_GEOIDs_work, regular_cells, by = c("u_id", "GEOID")))
### second iterate 
df_step3_2_work <- regular_cells_2_work %>% 
  filter(u_id %in% twoWork_neighbous$u_id) %>% 
  select(c(u_id, GEOID, created_at, year, month, day, day_counts, month_counts, total_counts,n_day)) %>% 
  unite(date, year, month, day, sep = "-") %>% 
  mutate(date = as.Date(date)) %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, function(x) get_topN_GEOID(x, 2))) %>% 
  select(-data) %>% 
  unnest() %>% 
  ungroup() %>% 
  left_join(., regular_cells) 

if(file.exists("anchor_results_2_work.csv")){
  anchor_results_2_work <- read_csv("anchor_results_2_work.csv") %>% 
    mutate(GEOID = as.character(GEOID)) 
} else{
  anchor_results_2_work <- df_step3_2_work %>% 
    group_by(u_id, GEOID) %>% 
    nest() %>% 
    mutate(detect=future_map(data, determine_anchor_type)) %>% 
    select(-data) %>% 
    unnest() %>% 
    group_by(u_id) %>% 
    mutate(anchor_type_n = n_distinct(anchor_type),
           n_geoid = n_distinct(GEOID)) %>% 
    ungroup()
  write_csv(anchor_results_2_work, path = "anchor_results_2_work.csv")
}

## add to dataset for each type
oneWork <- bind_rows(oneWork, (anchor_results_2_work %>% filter(n_geoid == 1) %>% filter(anchor_type == "work place")))
oneHome_oneWork <- append(oneHome_oneWork, (anchor_results_2_work %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 2)))


twoWork_2 <- anchor_results_2_work %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 1) %>% filter(anchor_type == "work place")
twoWork_2 <- twoWork_2  %>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id) %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) %>% 
  left_join(twoWork_2, ., by = c("u_id"))  

## add to dataset 
twoWork_not_neighbous <- bind_rows(twoWork_not_neighbous, twoWork_2 %>% filter(neighboring == "non-neighboring cell") %>% select(-neighboring))

twoWork_neighbous <- twoWork_2 %>% filter(neighboring == "neighboring cell") %>% select(-neighboring) %>% left_join(., regular_cells)

# third iterate 
## in case the anchor points were located in neighboring cells, keep the most visited anchor point.
twoWork_Neigh_mostVisit <- twoWork_neighbous %>% 
  unite(date, year, month, day, sep = "-") %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, mostVisit_anchor_detect) %>% unlist()) %>% 
  select(-data) %>% 
  mutate(anchor_type = "work place")

removed_GEOIDs_work <- remove_second_GEOID(twoWork_neighbous, twoWork_Neigh_mostVisit)

## remove secondary GEOID dataset and get new regular cell, repeat stage 3 procesure 
regular_cells_3_work <- anti_join(regular_cells, left_join(removed_GEOIDs_work, regular_cells, by = c("u_id", "GEOID")))
### second iterate 
df_step3_3_work <- regular_cells_3_work %>% 
  filter(u_id %in% twoWork_neighbous$u_id) %>% 
  select(c(u_id, GEOID, created_at, year, month, day, day_counts, month_counts, total_counts,n_day)) %>% 
  unite(date, year, month, day, sep = "-") %>% 
  mutate(date = as.Date(date)) %>% 
  group_by(u_id, GEOID) %>% 
  summarise(n_date = n_distinct(date),
            n_tweets = n()) %>% 
  group_by(u_id) %>% 
  arrange(., desc(n_date), desc(n_tweets)) %>% 
  nest() %>% 
  mutate(GEOID = future_map(data, function(x) get_topN_GEOID(x, 2))) %>% 
  select(-data) %>% 
  unnest() %>% 
  ungroup() %>% 
  left_join(., regular_cells) 

if(file.exists("anchor_results_3_work.csv")){
  anchor_results_3_work <- read_csv("anchor_results_3_work.csv") %>% 
    mutate(GEOID = as.character(GEOID)) 
} else{
  anchor_results_3_work <- df_step3_3_work %>% 
    group_by(u_id, GEOID) %>% 
    nest() %>% 
    mutate(detect=future_map(data, determine_anchor_type)) %>% 
    select(-data) %>% 
    unnest() %>% 
    group_by(u_id) %>% 
    mutate(anchor_type_n = n_distinct(anchor_type),
           n_geoid = n_distinct(GEOID)) %>% 
    ungroup()
  write_csv(anchor_results_3_work, path = "anchor_results_3_work.csv")
}

## add to dataset for each type
oneWork <- bind_rows(oneWork, (anchor_results_3_work %>% filter(n_geoid == 1) %>% filter(anchor_type == "work place")))
oneHome_oneWork <- append(oneHome_oneWork, (anchor_results_3_work %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 2)))


twoWork_3 <- anchor_results_3_work %>% filter(n_geoid == 2) %>% filter(anchor_type_n == 1) %>% filter(anchor_type == "work place")
twoWork_3 <- twoWork_3  %>% 
  left_join(., acs_ky %>% st_set_geometry(NULL), by = c("GEOID")) %>% 
  arrange(., u_id) %>% 
  group_by(u_id) %>% 
  nest() %>% 
  mutate(neighboring = future_map(data, detect_neighbor) %>% unlist()) %>% 
  select(-data) %>% 
  left_join(twoWork_3, ., by = c("u_id"))  


## add to dataset 
twoWork_not_neighbous <- bind_rows(twoWork_not_neighbous, twoWork_3 %>% filter(neighboring == "non-neighboring cell") %>% select(-neighboring))
twoWork_neighbous <- twoWork_3 %>% filter(neighboring == "neighboring cell") %>% select(-neighboring) %>% left_join(., regular_cells)
```







